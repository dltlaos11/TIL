# static 키워드, 추상화, 컴파일러와 인터프리터

## 1. static 키워드

### 개념과 특징

- static 키워드는 클래스에 속하는 변수나 메서드를 정의할 때 사용
- 인스턴스가 아닌 클래스에 속하며, 모든 인스턴스가 공유
- `클래스명.멤버`로 직접 접근 가능

### 장점

- 메모리 효율성: 인스턴스 간 공유로 중복 메모리 사용 감소
- 유틸리티 함수: 인스턴스 생성 없이 사용 가능
- 명시성: 클래스 소속임을 명확히 표현
- 상수 관리: 클래스 전체에서 사용하는 상수 관리에 효과적

### 단점

- 메모리 관리: 프로그램 종료 시까지 GC로 회수되지 않음
- 객체지향 원칙 약화: 캡슐화, 상속 원칙 훼손 가능성
- 테스트 어려움: 모킹이 어려워 단위 테스트 복잡
- 동시성 문제: 멀티스레드 환경에서 동기화 문제 발생 가능
- 런타임 다형성 제한: 오버라이딩 불가

## 2. 추상화 (Abstraction)

### 개념

추상화는 복잡한 시스템에서 핵심만을 추출하고 세부사항을 감추어 복잡도를 낮추는 방법입니다.

### 유형

1. **데이터 추상화**: 여러 데이터의 공통점을 모으고 차이점은 제거 (예: 고양이, 강아지 → '동물')
2. **프로세스 추상화**: 내부 작동 원리를 숨기고 단순한 인터페이스 제공 (예: DB 쿼리\_MySQL 아키텍처)

### 이점

- 복잡성 관리: 시스템을 더 작고 관리하기 쉬운 부분으로 분리
- 재사용성 향상: 공통 기능을 여러 곳에서 재사용
- 유지보수 용이성: 인터페이스가 유지되면 구현 변경이 다른 코드에 영향 최소화
- 이해도 향상: 시스템의 본질적 특성만 보여줌
- 확장성: 인터페이스 유지하며 내부 구현 변경 가능

## 3. 컴파일러와 인터프리터

### 기계어

- 컴퓨터 프로세서가 직접 이해하고 실행할 수 있는 0과 1로 이루어진 이진 명령어

### 컴파일러

- 소스 코드 전체를 한 번에 기계어로 변환 후 실행
- 컴파일 시간 소요되나 실행 속도 빠름
- 코드 수정 시 재컴파일 필요
- 예시 언어: C, C++, Go, Rust

### 인터프리터

- 소스 코드를 한 줄씩 읽어 즉시 변환 및 실행
- 초기 시작 빠르나 전체 실행 속도는 상대적으로 느림
- 코드 수정 후 바로 실행 가능
- 예시 언어: Python, JavaScript(브라우저), Ruby

### JIT 컴파일러

- 인터프리터와 컴파일러의 중간 형태
- 실행 중 자주 사용되는 코드(hot code)만 선별적으로 컴파일하여 최적화
- **장점**: 자주 사용되는 코드의 실행 속도가 크게 향상됨
- **단점**: 컴파일된 코드를 메모리에 캐싱하므로 인터프리터 방식보다 더 많은 메모리 소비
- 작동 과정:
  1. 코드 분석: 실행 중 자주 사용되는 부분(hot spot) 식별
  2. 동적 컴파일: 해당 부분만 기계어로 변환
  3. 최적화: 다양한 최적화 기법 적용
  4. 실행: 최적화된 코드 실행 및 지속적 분석/최적화
- 예시: JVM, .NET Framework, V8 엔진

### 선택 기준

- 성능 중시: 컴파일러
- 개발 속도 중시: 인터프리터
- 균형적 접근: JIT 컴파일러
