# 커맨드 패턴 종합 정리

## 작업 큐와 커맨드 패턴의 관계

1. **작업 큐의 의미**:

   - 커맨드 패턴에서 작업 큐는 **커맨드 객체들을 순차적으로 저장하고 실행**하는 메커니즘
   - 일반적인 큐 자료구조와 개념은 같지만, 저장 대상이 실행 가능한 **커맨드 객체**

2. **작업 큐의 활용**:
   - 트랜잭션 처리: 여러 작업을 큐에 넣고 순서대로 실행
   - 매크로 커맨드: 여러 명령을 그룹화하여 한 번에 실행
   - 작업 스케줄링: 특정 시간에 실행할 작업 등록

## 커맨드 패턴과 인터페이스 확장 문제

1. **문제 상황**:

   - Command 인터페이스에 새 메서드(예: `undo()`)를 추가하면 **모든 구현 클래스가 영향**을 받음
   - 이는 **개방-폐쇄 원칙**(OCP)을 위반하는 변경

2. **해결 방안**:
   - **인터페이스 분리**: 기본 `Command`와 확장된 `UndoableCommand` 등으로 분리
   - **디폴트 메서드**: Java 8+ 에서는 기본 구현 제공
   - **데코레이터/어댑터 패턴**: 기존 커맨드를 확장하는 래퍼 클래스 활용

## 다중 인터페이스와 커맨드 패턴

1. **다중 인터페이스 활용 가능성**:

   - 커맨드 패턴에서 **여러 인터페이스 사용은 패턴의 취지에 벗어나지 않음**
   - 오히려 **인터페이스 분리 원칙**에 부합하는 설계

2. **다중 인터페이스의 장점**:
   - **필요한 기능만 노출**: 클라이언트에 따라 필요한 인터페이스만 제공
   - **점진적 확장 가능**: 기존 코드 수정 없이 새 기능 추가
   - **유연한 조합**: 기능별 인터페이스로 다양한 커맨드 유형 지원

## 커맨드 패턴과 전략 패턴의 유사점

1. **인터페이스 의존성**:

   - 두 패턴 모두 인터페이스에 새 메서드 추가 시 **같은 문제** 발생
   - 모든 구현체가 새 메서드를 구현해야 하는 부담

2. **해결 방법의 유사성**:

   - **인터페이스 분리**: 기본/확장 인터페이스로 분리
   - **컴포지션 활용**: 어댑터나 데코레이터 패턴 활용
   - **기존 코드 보존**: 기존 구현체는 유지하고 새 구현체만 확장

3. **차이점**:
   - **목적의 차이**: 커맨드 패턴은 요청 캡슐화, 전략 패턴은 알고리즘 교체
   - **구조의 차이**: 커맨드는 요청자-수행자 분리, 전략은 컨텍스트-알고리즘 분리

## 실무적 교훈

1. **인터페이스 설계의 중요성**:

   - 처음부터 **확장 가능성을 고려**한 인터페이스 설계
   - 인터페이스는 **작고 집중적**으로 유지

2. **점진적 확장 전략**:

   - 기존 코드 수정보다는 **확장을 통한 기능 추가**
   - **컴포지션 활용**으로 유연한 기능 조합

3. **패턴 조합의 강점**:
   - 커맨드 패턴 + 작업 큐 = 강력한 명령 관리
   - 커맨드 패턴 + 인터페이스 분리 = 유연한 확장성
   - 커맨드 패턴 + 데코레이터/어댑터 = 기존 코드 재사용

## 최종 정리

커맨드 패턴은 요청을 객체로 캡슐화하여 요청자와 수행자를 분리하는 강력한 디자인 패턴입니다. 작업 큐를 활용하면 명령의 순차 실행, 트랜잭션 처리, 매크로 기능 등을 구현할 수 있습니다.

인터페이스 변경 문제는 인터페이스 분리와 컴포지션을 통해 해결할 수 있으며, 이는 전략 패턴에서도 유사하게 적용됩니다. 결국 좋은 객체지향 설계는 **확장에는 열려있고 수정에는 닫혀있는** 구조를 추구하며, 커맨드 패턴도 이러한 원칙에 따라 유연하고 확장 가능한 방식으로 구현될 때 최대의 가치를 발휘합니다.
