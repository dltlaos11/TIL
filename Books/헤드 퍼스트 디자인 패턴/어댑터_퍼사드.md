# 어댑터, 퍼사드 패턴

**Date**: 2025-05-31

## 📚 오늘 학습한 내용

### 1. 어댑터 패턴 (Adapter Pattern)

**핵심 개념**: 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있도록 해주는 패턴

#### 구성 요소

- **타깃 인터페이스**: 클라이언트가 기대하는 인터페이스 (예: `Shape`)
- **어댑티**: 기존에 존재하는 호환되지 않는 클래스 (예: `LegacyRectangle`)
- **어댑터**: 타깃 인터페이스를 구현하면서 어댑티를 내부에서 사용하는 변환기

#### 객체 어댑터 vs 클래스 어댑터

- **객체 어댑터**: 컴포지션 사용, 더 유연함 (Java 권장)
- **클래스 어댑터**: 상속 사용, 다중상속 필요 (Java에서 제한적)

```java
// 객체 어댑터 예시
class RectangleAdapter implements Shape {
    private LegacyRectangle legacyRectangle;  // 컴포지션

    public RectangleAdapter(LegacyRectangle legacyRectangle) {
        this.legacyRectangle = legacyRectangle;
    }

    @Override
    public void draw(int x, int y, int width, int height) {
        // 인터페이스 변환
        legacyRectangle.oldDraw();
    }
}
```

### 2. 퍼사드 패턴 (Facade Pattern)

**핵심 개념**: 복잡한 서브시스템에 대한 단순한 인터페이스를 제공하는 패턴

- **목적**: 복잡성 단순화 (인터페이스 변환이 아님)
- **관계**: 1:N (하나의 인터페이스로 여러 클래스 제어)

```java
class ComputerFacade {
    private CPU cpu;
    private Memory memory;
    private HardDrive hardDrive;

    public void startComputer() {
        // 복잡한 부팅 과정을 간단한 메소드로
        cpu.freeze();
        memory.load(0, hardDrive.read(0, 1024));
        cpu.execute();
    }
}
```

### 3. 데코레이터 패턴 (Decorator Pattern)

**핵심 개념**: 객체를 장식하는 패턴 (인터페이스를 장식하는 것이 아님!)

#### 주요 특징

- **컴포지션 활용**: 상속 대신 객체를 감싸는 방식
- **런타임 기능 추가**: 동적으로 기능 조합 가능
- **투명성**: 장식된 객체와 원본 객체가 같은 인터페이스

```java
// 컴포지션이 적용되는 부분들
abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;  // 1. 객체 포함 (has-a)

    public String getDescription() {
        return coffee.getDescription() + " + 추가재료";  // 2. 위임
    }
}

// 3. 객체 중첩 (여러 데코레이터를 겹겹이 감싸기)
Coffee fancy = new ChocolateDecorator(
    new MilkDecorator(
        new BasicCoffee()
    )
);
```

### 4. 컴포지션 (Composition) = 조합의 개념

**핵심**: 여러 부분 객체들을 조합해서 전체 객체를 구성

#### 컴포지션의 형태

- **집합(Aggregation)**: 약한 조합, 부분이 독립적 존재 가능
- **컴포지션(Composition)**: 강한 조합, 부분이 전체에 종속

#### 장점

- **모듈성**: 각 부분을 독립적으로 개발
- **재사용성**: 같은 부분을 다른 조합에서 재사용
- **유연성**: 런타임에 조합 변경 가능

### 5. 최소지식원칙 (디미터 법칙)

**핵심**: "친구하고만 대화하라" - 직접적인 의존성과만 상호작용

#### 단순한 "떠넘기기"가 아닌 이유

1. **책임의 적절한 분배**: 각 객체가 자신의 데이터 관련 로직 담당
2. **캡슐화 강화**: 내부 구조 변경이 외부에 영향 없음
3. **의미있는 추상화**: 비즈니스 의미가 명확한 메소드 제공
4. **에러 처리 개선**: null 체크가 적절한 위치에

#### 단점

- **래퍼 메소드 증가**: 내부 객체 접근을 위한 래퍼 메소드들이 폭발적으로 증가
- **코드 중복**: 대부분 단순 위임 형태의 반복

### 6. 상속보다는 구성을 활용해야 하는 이유

#### 상속의 문제점

- **경직된 계층구조**: 컴파일 타임에 관계 고정
- **다중 상속 제약**: Java는 단일 상속만 지원
- **깨지기 쉬운 기반 클래스**: 부모 클래스 변경이 자식에게 영향
- **LSP 위반 가능성**: 펭귄은 Bird이지만 날 수 없음

#### 구성의 장점

- **유연성**: 런타임에 행동 조합 가능
- **다중 행동 조합**: 여러 기능을 자유롭게 조합
- **느슨한 결합도**: 변경에 대한 내성
- **테스트 용이성**: Mock 객체 주입 가능

### 7. 의존성 역전 원칙

**핵심**: "구상 클래스가 아닌 추상화에 의존하라"

#### 용어 정리

- **구상 클래스**: 실제 구현이 있는 일반 클래스 (예: `MySQLDatabase`)
- **추상화**: 인터페이스 또는 추상 클래스 (예: `Database`)

#### 장점

- **유연성**: 구현 변경 시 코드 수정 불필요
- **확장성**: 새로운 구현 추가 시 기존 코드 안전
- **테스트성**: Mock 객체 쉽게 주입 가능

## 🤔 오늘의 깨달음

1. **패턴의 목적이 중요하다**: 어댑터는 변환, 퍼사드는 단순화, 데코레이터는 기능 확장
2. **컴포지션은 단순한 조합이 아니다**: 적절한 책임 분배와 캡슐화가 핵심
3. **좋은 원칙도 과하면 독이 된다**: 최소지식원칙의 래퍼 메소드 폭증 문제
4. **구상 클래스 = 일반 클래스**: 어려운 용어가 아니라 평범한 개념

## 🔄 앞으로 학습할 것

- [ ] 전략 패턴과 상태 패턴의 차이점
- [ ] 팩토리 패턴들의 종류와 차이점
- [ ] 옵저버 패턴의 실제 활용 사례
- [ ] SOLID 원칙의 실무 적용 방법

## 💡 실무 적용 아이디어

- 레거시 시스템 연동 시 어댑터 패턴 활용
- 복잡한 API 호출을 퍼사드로 단순화
- 기능 확장이 필요한 부분에 데코레이터 패턴 고려
- 인터페이스 설계 시 의존성 역전 원칙 적용
