# HTTP 완벽 가이드 16장: 국제화

## 🎯 핵심 깨달음: "파일 인코딩과 선언된 인코딩이 일치해야 한다"

### 우선순위의 진실

1. **HTTP 응답 헤더의 charset** (최우선!)
2. **HTML meta 태그의 charset**
3. **브라우저의 자동 감지**

이 우선순위는 Live Server 실험을 통해 직접 체험했다. Live Server가 자동으로 `Content-Type: text/html; charset=UTF-8` 헤더를 추가하여, 파일의 실제 인코딩과 관계없이 UTF-8로 강제 해석되는 현상을 발견했다.

## 🔬 실험 결과 매트릭스

| 파일 저장 | meta charset | 결과    | 이유                              |
| --------- | ------------ | ------- | --------------------------------- |
| UTF-8     | UTF-8        | ✅ 정상 | 완벽한 일치                       |
| UTF-8     | EUC-KR       | ❌ 깨짐 | UTF-8 바이트를 EUC-KR로 잘못 해석 |
| EUC-KR    | UTF-8        | ❌ 깨짐 | EUC-KR 바이트를 UTF-8로 잘못 해석 |
| EUC-KR    | EUC-KR       | ✅ 정상 | 완벽한 일치                       |

### 깨짐 패턴의 차이

- **UTF-8 → EUC-KR**: 한글과 � (대체 문자) 섞여서 나타남
- **EUC-KR → UTF-8**: 주로 영어만 보이고 한글은 모두 깨짐

## 💡 UTF-8의 똑똑한 설계

### 가변길이 인코딩

- **영어 'A'**: 1바이트 (`01000001`)
- **한글 '한'**: 3바이트 (`11101101 10010101 10011100`)
- **이모지 '😀'**: 4바이트

### 자기 동기화 (Self-Synchronizing) 특성

UTF-8의 각 바이트는 자신의 역할을 명시:

```
0xxxxxxx → 1바이트 문자 (ASCII)
110xxxxx → 2바이트 문자의 시작
1110xxxx → 3바이트 문자의 시작
11110xxx → 4바이트 문자의 시작
10xxxxxx → 연속 바이트
```

**핵심 깨달음**: 바이트 스트림 중간에서 읽기 시작해도, `10`으로 시작하는 바이트를 만나면 "아, 이건 중간이구나"를 알고 다음 시작 바이트를 찾을 수 있다.

## 🔄 EUC-KR vs UTF-8: 손실 복구 능력

### 바이트 손실 시나리오

**UTF-8**: 손실된 부분만 깨지고 다음 문자부터 자동 복구

```
정상: 안 녕 하
손실: 안 � 하 (한 문자만 영향)
```

**EUC-KR**: 손실 이후 모든 문자가 엉망이 됨

```
정상: [A1 A2] [B1 B2] [C1 C2]
손실: [A1 A2] [B1 ??] → 이후 전부 어긋남
```

**깨달음**: EUC-KR은 "여기가 시작"이라는 표식이 없어서, 한 바이트만 손실되어도 이후 바이트들이 엉뚱하게 묶여 해석된다.

## 🌐 URL 인코딩의 이유

"안녕"이 `%EC%95%88%EB%85%95`가 되는 이유:

- UTF-8 바이트: `EC 95 88 EB 85 95`
- URL 인코딩: 각 바이트를 `%XX` 형태로 표현

**깨달음**: URL에서 안전하게 사용할 수 있는 문자만으로 표현하여, 데이터와 URL 특수문자를 명확히 구분한다.

## 🔧 실무 디버깅 체크리스트

문자 깨짐 문제 발생 시:

1. **HTTP 응답 헤더** 확인 (`Content-Type`)
2. **브라우저 인식** 확인 (`document.characterSet`)
3. **파일 실제 인코딩** 확인 (VSCode 하단 상태바)
4. **HTML meta charset** 확인
5. **서버 설정** 확인 (Live Server 같은 도구의 기본값)

## 📚 Accept-Language와 Content-Language

### Accept-Language (요청)

```
Accept-Language: ko-KR,ko;q=0.9,en;q=0.8
```

- `q=0.9`: 선호도 (0~1, 기본값 1.0)
- 서버는 이를 참고해 적절한 언어로 응답

### Accept-Language의 실제 기준 (Chrome 기준)

📌 **1) Chrome 설치 직후 (사용자 설정 전)**

- OS 언어 = Chrome 언어
- Chrome 언어 = Accept-Language

📌 **2) Chrome에서 언어 설정 변경 후**
Chrome Settings → Languages 메뉴에서 순서를 바꾸면:

- Chrome 언어 설정 = Accept-Language
- OS 언어와 무관하게 변경됨

#### 실제 예시

📱 **OS가 영어인데 Chrome 설치함**

Chrome 설치 직후 Accept-Language는:

```
Accept-Language: en-US,en;q=0.9
```

🙋 **사용자가 Chrome 설정에서 한국어를 최상단으로 올림**

그러면 자동으로 변경됨:

```
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```

✔ **결론**: Chrome 설치할 때 선택하는 언어가 기준이 아니라, Chrome 내부 "Languages" 설정이 Accept-Language의 진짜 기준이다. 별도 설정을 안 하면 OS 언어가 기본값이 될 뿐이다.

**중요**: 시크릿 모드에서도 Accept-Language는 그대로 전송된다. 이는 브라우저 설정이지 사용자 개인정보가 아니기 때문이다.

### Content-Language (응답)

서버가 "이 콘텐츠는 한국어야"라고 알려주는 헤더 (실제로는 잘 안 쓰임)

### 언어 전환 버튼의 진실

Accept-Language와는 무관! 실제로는:

- URL 경로 변경 (`/ko/`, `/en/`)
- 서브도메인 변경 (`ko.site.com`)
- 쿠키나 URL 파라미터 활용

**깨달음**: Accept-Language는 초기 방문 시 기본 언어 자동 설정용이다.

## 🎓 전체적인 맥락과 통찰

이 여정을 통해 깨달은 것은 **"인코딩은 약속"**이라는 점이다.

- 저장할 때의 약속 (파일 인코딩)
- 전송할 때의 약속 (HTTP 헤더)
- 해석할 때의 약속 (meta charset)

이 세 가지가 모두 일치해야 문자가 제대로 보인다.

UTF-8이 사실상의 표준이 된 이유도 명확해졌다:

1. ASCII와의 완벽한 호환성
2. 자기 동기화로 인한 오류 복구 능력
3. 가변길이로 인한 효율성
4. 명확한 바이트 패턴으로 인한 디버깅 용이성

HTTP 완벽 가이드를 읽을 때 단순히 "UTF-8을 써라"가 아니라, **왜** UTF-8인지, **어떻게** 동작하는지를 체험적으로 이해하게 되었다.
