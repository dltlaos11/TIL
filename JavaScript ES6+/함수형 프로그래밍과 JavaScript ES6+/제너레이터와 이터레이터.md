 # 재너레이터/이터레이터
 - 재너레이터 : 이터레이터이자 이터러블을 생성하는 함수, 이터레이터를 리턴하는 함수 🧐

```javascript
const log = console.log;

// 재너레이터는 일반 함수에서 앞에 *을 붙여서 재너레이터 함수를 만듦.
function *gen() {
    yield 1;
    yield 2; // if (false) yield 2; => 1 \n 3, 재너레이터는 이런 문장을 값으로 만들 수 있고 이 문장을 통해서 순회 할 수 있는 "값"을 만들 수 있기 떄문에 자바스크립트에서는 재너레이터를 통해서 "어떤 값이나 어떤 상태든 순회 할 수 있도록" 만들 수 있다. 😗 이 점은 굉장히 상징적이고 함수형 프로그래밍 관점에서도 중요, JS는 다형성이 높다. 재너레이터를 통해서 순회할 수 있는 값을 만들 수 있다는 이야기는 어떤 값도 순회할 수 있는 형태로 재너레이터라는 문장을 통해 조작할 수 있다. 재너레이터를 통해서 다양한 값들을 순회할 수 있는 이터러블을 쉽게 만들 수 있다.
    yield 3;
    return 100; // 🤔 done: true일 떄 나오는 값
}


let iter = gen();
// 재너레이터를 실행한 결과는 이터레이터다.

log(iter[Symbol.iterator]); // f [Symbol.iterator](){ [native code] }
// iter(이터레이터이자 이터러블)은 [Symbol.iterator]를 가지고 있고 
log(iter[Symbol.iterator]() == iter); // true
// [Symbol.iterator]의 실행 결과는 자기 자신. 
// 재너레이터는 well-formed 이터레이터를 리턴하는 함수 


log(iter.next()); // {value: 1, done: false}
log(iter.next()); // {value: 2, done: false}
log(iter.next()); // {value: 3, done: false}
log(iter.next()); // {value: undefined, done: true} 🤔 but *gen() 재너레이터에 return이 있다면 {value: 100, done: true}을 반환 

for (const a of gen()) log(a); // 1 \n 2 \n 3
// 재너레이터를 사용하게 되면 실행결과가 이터러블이자 이터레이터이기 떄문에 순회 가능. 어떤 값이든 이터러블이면 순회 가능
// 🤔 *gen()에 return이 생겨도 return을 제외하고 순회한다.


```

# odds
```javascript
function *odds(l) {
    for (let i = 0; i < l; i++) {
        if (i % 2) yield i;
    }
}

let iter2 = odds(10);
log(iter2.next()); // {value: 1, done: false}
log(iter2.next()); // {value: 3, done: false}
log(iter2.next()); // {value: 5, done: false}
log(iter2.next()); // {value: 7, done: false}
log(iter2.next()); // {value: 9, done: false}
log(iter2.next()); // {value: undefined, done: true}
log(iter2.next()); // {value: undefined, done: true}
```

# for of, 전개 연산자, 구조 분해, 나머지 연산자

<script>
</script>