# 코드를 값으로 다루어 표현력 높이기 🤔

## go🟢
함수형 프로그래밍에서는 코드를 값으로 다루는 아이디어를 많이 사용 !<br>
어떤 함수가 코드인 함수를 받아서 평가하는 시점을 원하는대로 다룰 수 있으므로 코드의 표현력을 높인다던지 많은 아이디어가 있다.
```javascript
 const reduce = (f, acc, iter) => {
    if (!iter) {
        iter = acc[Symbol.iterator](); 
        acc = iter.next().value;
    } 
    for (const a of iter) {
        acc = f(acc, a);
    }
    return acc; 
 };

인자를 받아서 하나의 값으로 축약하는 go 함수
const go = (...list) => {
    log(list); // [0, f, f, f, f]
};

go( // 인자를 리스트로 묶어 하나의 값, list로 생각하여 []를 사용하여 표현하거나 함수 호출부분에서 인자에 ...전개연산자 사용하여 표현
    0, // 첫번째 인자를 다음 함수의 인자로 전달
    a => a+1, // 계속적으로 하나의 일을 수행 
    a => a+10, // 이 로직은 reduce와 동일🟢
    a => a+100,
    console.log
);
//111

// args를 어떤 특정 함수로 축약해서 하나의 값으로 만들어나가는 것
const go = (...args) => reduce((a, f) => f(a), args);
// f(a)가 다음 번쨰 인자가 된다.
go(
    0,
    a => a+1,
    a => a+10,
    a => a+100,
    console.log
); // 111

// go함수의 경우는 시작하는 인자가 2개일 떄 아래와 같이 구현 가능
go(
    add(0,1), // 1, 인자 2개를 평가해서 1로
    a => a+10,
    a => a+100,
    console.log
); 
```

## pipe🟢
* * *
함수를 리턴하는 함수, go 함수는 즉시 함수들과 인자들을 전달해서 어떤 값을 평가하는데 사용한다면 pipe 함수는 함수들이 나열되어 있는 합성된 함수를 만드는 함수이다.
<br>

```javascript

const pipe = () => {};
const pipe = (...fs) => (a) => go(a, ...fs); // 함수를 리턴하는 함수이기에 함수추가.
// pipe 함수는 결국엔 내부에서 go를 사용하는 함수
// fs는 내부에서 실행되는 함수들
// a는 인자를 받는 것 
// 받은 인자를 go 함수를 실행하면서 인자를 주고 두번쨰 인자로 함수를 주면 pipe함수가 만들어진다.📗


const f = pipe(
    a => a+1,
    a => a+10,
    a => a+100,
); // 3개의 함수들을 연속적으로 실행하면서 축약하는 하나의 함수를 만들어서 f에 함수를 리턴하는 것.

log(f(0)); // 111
log(f(add(0,1))); // 파이프 함수의 인자가 2개일 경우 출력하여 인자를 전달하는 부분에서 실행. 

const f = pipe(
    (a, b) => a+b, // 인자를 2개 받는 함수를 사용할 수 있도록 첫번째 함수의 경우는 인자를 2개이상 전달할 수 있도록 구성
    a => a+10,
    a => a+100,
);

const pipe = (...fs) => (...as) => go(a, ...fs); 
// f가 받을 인자 ...as, 여러개 인자를 받도록,
// go 함수처럼 첫번째 함수에는 인자를 펼쳐서 전달하고 그 다음 함수들이 실행되도록 하면 된다.
const pipe = (f, ...fs) => (...as) => go(f(...as), ...fs);
// 위와 같이 해주면 첫번쨰 함수만 꺼내고 나머지 함수들을 뒤에 넣을 수 있다.
// go함수 인자를 2개받을 떄와 유사 

log(f(0,1)); // 111

```