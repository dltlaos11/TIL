# ë©€í‹°ì“°ë ˆë“œ í™˜ê²½ì—ì„œì˜ ì“°ë ˆë“œ ì•ˆì „ì„±ê³¼ ë™ì‹œì„± ì œì–´

## ğŸ”’ ì“°ë ˆë“œ ì„¸ì´í”„ (Thread Safe)

**ì—¬ëŸ¬ ì“°ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•´ë„ ë°ì´í„° ì¼ê´€ì„±ê³¼ ì •í™•ì„±ì´ ë³´ì¥ë˜ëŠ” ê²ƒ**

### ì“°ë ˆë“œ ì„¸ì´í”„í•˜ì§€ ì•Šì€ ì˜ˆì‹œ

```java
public class UnsafeCounter {
    private int count = 0;

    public void increment() {
        count++;  // ìœ„í—˜! Race Condition ë°œìƒ ê°€ëŠ¥
        // ì‹¤ì œë¡œëŠ”: 1) count ì½ê¸° â†’ 2) count+1 ê³„ì‚° â†’ 3) ê²°ê³¼ ì €ì¥
    }

    public int getCount() {
        return count;
    }
}

// ë¬¸ì œ ìƒí™© ì‹œë‚˜ë¦¬ì˜¤:
// ì“°ë ˆë“œ 1: countë¥¼ ì½ìŒ (0)
// ì“°ë ˆë“œ 2: countë¥¼ ì½ìŒ (0) - ë™ì‹œì—!
// ì“°ë ˆë“œ 1: countë¥¼ 1ë¡œ ì—…ë°ì´íŠ¸
// ì“°ë ˆë“œ 2: countë¥¼ 1ë¡œ ì—…ë°ì´íŠ¸
// ê²°ê³¼: 2ê°€ ë˜ì–´ì•¼ í•˜ì§€ë§Œ 1ì´ ë¨!
```

### ì“°ë ˆë“œ ì„¸ì´í”„í•œ í•´ê²°ì±…ë“¤

#### 1. synchronized ì‚¬ìš©

```java
public class SafeCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;  // í•œ ë²ˆì— í•˜ë‚˜ì˜ ì“°ë ˆë“œë§Œ ì ‘ê·¼
    }

    public synchronized int getCount() {
        return count;
    }
}
```

#### 2. AtomicInteger ì‚¬ìš©

```java
public class AtomicCounter {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet();  // ì›ìì  ì—°ì‚°
    }

    public int getCount() {
        return count.get();
    }
}
```

#### 3. Lock ì‚¬ìš©

```java
public class LockCounter {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
```

## ğŸ§µ ì“°ë ˆë“œ ë¡œì»¬ (ThreadLocal)

**ê° ì“°ë ˆë“œë§ˆë‹¤ ë…ë¦½ì ì¸ ë³€ìˆ˜ ë³µì‚¬ë³¸ì„ ê°€ì§€ê²Œ í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜**

### ê¸°ë³¸ ì‚¬ìš©ë²•

```java
public class ThreadLocalExample {
    // ê° ì“°ë ˆë“œë§ˆë‹¤ ë³„ë„ì˜ SimpleDateFormat ì¸ìŠ¤í„´ìŠ¤
    private static final ThreadLocal<SimpleDateFormat> DATE_FORMAT =
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));

    // ê° ì“°ë ˆë“œë§ˆë‹¤ ë³„ë„ì˜ ì‚¬ìš©ì ì •ë³´
    private static final ThreadLocal<String> CURRENT_USER = new ThreadLocal<>();

    public static String formatDate(Date date) {
        return DATE_FORMAT.get().format(date);  // ê° ì“°ë ˆë“œì˜ ê³ ìœ  ì¸ìŠ¤í„´ìŠ¤
    }

    public static void setCurrentUser(String user) {
        CURRENT_USER.set(user);
    }

    public static String getCurrentUser() {
        return CURRENT_USER.get();
    }

    public static void clearCurrentUser() {
        CURRENT_USER.remove();  // ë©”ëª¨ë¦¬ ë¦¬í¬ ë°©ì§€
    }
}
```

### ì‹¤ì œ ë™ì‘ í™•ì¸

```java
public class ThreadLocalDemo {
    private static final ThreadLocal<Integer> THREAD_ID = new ThreadLocal<>();

    public static void main(String[] args) {
        // ë©”ì¸ ì“°ë ˆë“œ
        THREAD_ID.set(0);
        System.out.println("Main: " + THREAD_ID.get()); // 0

        // ì“°ë ˆë“œ 1
        new Thread(() -> {
            THREAD_ID.set(100);
            System.out.println("Thread1: " + THREAD_ID.get()); // 100
        }).start();

        // ì“°ë ˆë“œ 2
        new Thread(() -> {
            THREAD_ID.set(200);
            System.out.println("Thread2: " + THREAD_ID.get()); // 200
        }).start();

        // ë©”ì¸ ì“°ë ˆë“œëŠ” ìì‹ ì˜ ê°’ ìœ ì§€
        System.out.println("Main still: " + THREAD_ID.get()); // 0
    }
}
```

### ì‹¤ë¬´ ì‚¬ìš© ì‚¬ë¡€: ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬

```java
public class UserContext {
    private static final ThreadLocal<User> CURRENT_USER = new ThreadLocal<>();
    private static final ThreadLocal<String> REQUEST_ID = new ThreadLocal<>();

    public static void setUser(User user) {
        CURRENT_USER.set(user);
    }

    public static User getCurrentUser() {
        return CURRENT_USER.get();
    }

    public static void setRequestId(String requestId) {
        REQUEST_ID.set(requestId);
    }

    public static String getRequestId() {
        return REQUEST_ID.get();
    }

    // ìš”ì²­ ì™„ë£Œ í›„ ì •ë¦¬
    public static void clear() {
        CURRENT_USER.remove();
        REQUEST_ID.remove();
    }
}
```

## ğŸ”¬ volatile

**ë©”ëª¨ë¦¬ ê°€ì‹œì„±(Memory Visibility)ì„ ë³´ì¥í•˜ëŠ” í‚¤ì›Œë“œ**

### volatileì˜ íŠ¹ì§•

```java
public class VolatileExample {
    private volatile boolean stopFlag = false;  // volatile í‚¤ì›Œë“œ
    private int counter = 0;

    // ì“°ë ˆë“œ 1
    public void writer() {
        counter = 42;
        stopFlag = true;  // volatile ì“°ê¸° - ë©”ì¸ ë©”ëª¨ë¦¬ì— ì¦‰ì‹œ ë°˜ì˜
    }

    // ì“°ë ˆë“œ 2
    public void reader() {
        if (stopFlag) {  // volatile ì½ê¸° - ë©”ì¸ ë©”ëª¨ë¦¬ì—ì„œ ìµœì‹ ê°’ ì½ìŒ
            System.out.println(counter);  // 42ê°€ ì¶œë ¥ë¨ì„ ë³´ì¥
        }
    }
}
```

### volatileì˜ í•œê³„

```java
public class VolatileCharacteristics {
    private volatile long counter = 0;

    // âŒ ì´ê²ƒì€ ì“°ë ˆë“œ ì•ˆì „í•˜ì§€ ì•ŠìŒ!
    public void increment() {
        counter++;  // ì½ê¸° â†’ ì¦ê°€ â†’ ì“°ê¸° (3ë‹¨ê³„ ì—°ì‚°)
        // volatileì€ ì›ìì„±ì„ ë³´ì¥í•˜ì§€ ì•ŠìŒ
    }

    // âœ… ì´ê²ƒì€ ì“°ë ˆë“œ ì•ˆì „í•¨
    public void setValue(long value) {
        counter = value;  // ë‹¨ì¼ ì“°ê¸° ì—°ì‚°
    }

    // âœ… ì´ê²ƒë„ ì“°ë ˆë“œ ì•ˆì „í•¨
    public long getValue() {
        return counter;  // ë‹¨ì¼ ì½ê¸° ì—°ì‚°
    }
}
```

## âš›ï¸ AtomicReference

**ì°¸ì¡° ë³€ìˆ˜ì— ëŒ€í•œ ì›ìì  ì—°ì‚°ì„ ì œê³µí•˜ëŠ” í´ë˜ìŠ¤**

### ê¸°ë³¸ ì‚¬ìš©ë²•

```java
public class AtomicReferenceExample {
    private final AtomicReference<String> atomicString =
        new AtomicReference<>("initial");

    public void updateString(String newValue) {
        atomicString.set(newValue);  // ì›ìì  ì„¤ì •
    }

    public String getString() {
        return atomicString.get();  // ì›ìì  ì½ê¸°
    }

    // Compare-And-Swap (CAS) ì—°ì‚°
    public boolean updateIfEquals(String expect, String update) {
        return atomicString.compareAndSet(expect, update);
    }
}
```

### AtomicReferenceì˜ ê°•ë ¥í•œ ê¸°ëŠ¥ë“¤

```java
public class AdvancedAtomicReference {
    private final AtomicReference<User> currentUser = new AtomicReference<>();

    // 1. CASë¥¼ ì´ìš©í•œ ì•ˆì „í•œ ì—…ë°ì´íŠ¸
    public void updateUserAge(int newAge) {
        User currentUser, newUser;
        do {
            currentUser = this.currentUser.get();
            if (currentUser == null) return;

            newUser = new User(currentUser.getName(), newAge);
        } while (!this.currentUser.compareAndSet(currentUser, newUser));
    }

    // 2. updateAndGet - ì—…ë°ì´íŠ¸í•˜ê³  ìƒˆ ê°’ ë°˜í™˜
    public User incrementUserAge() {
        return currentUser.updateAndGet(user -> {
            if (user == null) return null;
            return new User(user.getName(), user.getAge() + 1);
        });
    }

    // 3. ë³µì¡í•œ ì—…ë°ì´íŠ¸ë„ Thread Safe
    public boolean incrementIfLessThan(int limit) {
        return currentUser.updateAndGet(user -> {
            if (user == null || user.getAge() >= limit) return user;
            return new User(user.getName(), user.getAge() + 1);
        }).getAge() <= limit;
    }
}
```

## ğŸ†š volatile vs AtomicReference ì„ íƒ ê¸°ì¤€

### volatile ì‚¬ìš© ì‹œì 

```java
// âœ… volatileë¡œ ì¶©ë¶„í•œ ê²½ìš°ë“¤
public class VolatileUseCase {
    private volatile boolean shutdownFlag = false;
    private volatile String configValue = "default";
    private volatile long lastUpdateTime = System.currentTimeMillis();

    // ë‹¨ìˆœí•œ ì½ê¸°/ì“°ê¸°ë§Œ ìˆìœ¼ë©´ Thread Safe
    public void setShutdownFlag(boolean flag) {
        shutdownFlag = flag;  // âœ… ë‹¨ìˆœ í• ë‹¹ - Thread Safe
    }

    public boolean isShutdownRequested() {
        return shutdownFlag;  // âœ… ë‹¨ìˆœ ì½ê¸° - Thread Safe
    }
}
```

### AtomicReferenceê°€ í•„ìš”í•œ ê²½ìš°

```java
// âŒ volatileë¡œëŠ” ë¶ˆì¶©ë¶„í•œ ê²½ìš°ë“¤
public class AtomicUseCase {
    private final AtomicReference<Integer> counter = new AtomicReference<>(0);

    public void increment() {
        counter.updateAndGet(current -> current + 1);  // âœ… ì›ìì  ì—°ì‚°
    }

    public void incrementBy(int value) {
        counter.updateAndGet(current -> current + value);  // âœ… ë³µí•© ì—°ì‚°
    }

    public int getAndIncrement() {
        return counter.getAndUpdate(current -> current + 1);  // âœ… ì›ìì  get-and-update
    }
}
```

## ğŸ“Š ì„ íƒ ê°€ì´ë“œ

| ìƒí™©                | volatile  | AtomicReference | synchronized |
| ------------------- | --------- | --------------- | ------------ |
| **ë‹¨ìˆœ í”Œë˜ê·¸**     | âœ… ì í•©   | âŒ ê³¼ë„í•¨       | âŒ ê³¼ë„í•¨    |
| **ë³µì¡í•œ ê°ì²´**     | âŒ ë¶ˆì¶©ë¶„ | âœ… ì í•©         | âœ… ì í•©      |
| **ì›ìì  ì—…ë°ì´íŠ¸** | âŒ ë¶ˆê°€ëŠ¥ | âœ… ê°€ëŠ¥         | âœ… ê°€ëŠ¥      |
| **ì„±ëŠ¥**            | ë¹ ë¦„      | ë³´í†µ            | ëŠë¦¼         |

## ğŸ—ºï¸ ThreadLocalì˜ ë‚´ë¶€ êµ¬ì¡°: ThreadLocalMap

**ThreadLocalì€ ë‚´ë¶€ì ìœ¼ë¡œ ThreadLocalMapì„ ì‚¬ìš©í•˜ì—¬ ê° ì“°ë ˆë“œë³„ ë°ì´í„°ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.**

### ThreadLocal ë™ì‘ ì›ë¦¬

```java
// Thread í´ë˜ìŠ¤ ë‚´ë¶€ êµ¬ì¡°
public class Thread {
    // ê° Thread ì¸ìŠ¤í„´ìŠ¤ê°€ ê°€ì§€ê³  ìˆëŠ” ThreadLocalMap
    ThreadLocal.ThreadLocalMap threadLocals = null;
}

// ThreadLocalì˜ ì‹¤ì œ ë™ì‘
public class ThreadLocal<T> {
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);  // í˜„ì¬ ì“°ë ˆë“œì˜ ThreadLocalMap ê°€ì ¸ì˜¤ê¸°
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);  // ì´ ThreadLocalì„ í‚¤ë¡œ ê°’ ì¡°íšŒ
            if (e != null) {
                return (T)e.value;
            }
        }
        return setInitialValue();
    }

    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            map.set(this, value);  // ì´ ThreadLocalì„ í‚¤ë¡œ ê°’ ì €ì¥
        } else {
            createMap(t, value);
        }
    }
}
```

### ThreadLocalMap ì˜ˆì‹œ

```java
public class ThreadLocalMapDemo {
    private static final ThreadLocal<String> USER_NAME = new ThreadLocal<>();
    private static final ThreadLocal<Integer> USER_ID = new ThreadLocal<>();
    private static final ThreadLocal<Date> LOGIN_TIME = new ThreadLocal<>();

    public static void demonstrateMap() {
        // í˜„ì¬ ì“°ë ˆë“œì˜ ThreadLocalMapì— ì—¬ëŸ¬ ê°’ ì €ì¥
        USER_NAME.set("Alice");     // ThreadLocalMap[USER_NAME] = "Alice"
        USER_ID.set(123);           // ThreadLocalMap[USER_ID] = 123
        LOGIN_TIME.set(new Date()); // ThreadLocalMap[LOGIN_TIME] = Dateê°ì²´

        // ìƒˆë¡œìš´ ì“°ë ˆë“œëŠ” ì™„ì „íˆ ë‹¤ë¥¸ ThreadLocalMap ë³´ìœ 
        new Thread(() -> {
            USER_NAME.set("Bob");   // ì´ ì“°ë ˆë“œì˜ ThreadLocalMap[USER_NAME] = "Bob"
            USER_ID.set(456);       // ì´ ì“°ë ˆë“œì˜ ThreadLocalMap[USER_ID] = 456
            // LOGIN_TIMEì€ ì„¤ì •í•˜ì§€ ì•ŠìŒ â†’ null

            System.out.println("Thread1 - Name: " + USER_NAME.get()); // Bob
            System.out.println("Thread1 - ID: " + USER_ID.get());     // 456
            System.out.println("Thread1 - Login: " + LOGIN_TIME.get()); // null
        }).start();

        // ë©”ì¸ ì“°ë ˆë“œëŠ” ìì‹ ì˜ ê°’ ìœ ì§€
        System.out.println("Main - Name: " + USER_NAME.get()); // Alice
        System.out.println("Main - ID: " + USER_ID.get());     // 123
    }
}
```

## ğŸ”’ DB Lock vs Java ë™ì‹œì„± ì œì–´

**ë™ì‹œì„± ì œì–´ëŠ” ì—¬ëŸ¬ ë ˆë²¨ì—ì„œ ê°€ëŠ¥í•©ë‹ˆë‹¤. ìƒí™©ì— ë§ê²Œ ì ì ˆí•œ ë ˆë²¨ì„ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.**

### ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ (Java)

```java
public class ApplicationLevelSync {
    private final AtomicReference<User> currentUser = new AtomicReference<>();
    private final AtomicInteger requestCount = new AtomicInteger(0);

    // ë©”ëª¨ë¦¬ ë‚´ ë°ì´í„° ë™ê¸°í™”
    public void updateUser(User newUser) {
        currentUser.set(newUser);  // ì›ìì  ì—…ë°ì´íŠ¸
    }

    public void incrementRequestCount() {
        requestCount.incrementAndGet();  // DB ì ‘ê·¼ ì—†ì´ ë©”ëª¨ë¦¬ì—ì„œë§Œ
    }
}
```

### ë°ì´í„°ë² ì´ìŠ¤ ë ˆë²¨

```java
@Service
@Transactional
public class DatabaseLevelSync {

    // 1. ê³„ì¢Œ ì´ì²´ (ë°ì´í„° ì¼ê´€ì„±ì´ ì¤‘ìš”)
    public void transferMoney(Long fromAccountId, Long toAccountId, BigDecimal amount) {
        // ë¹„ê´€ì  ë½ìœ¼ë¡œ ê³„ì¢Œ ì ê¸ˆ
        Account fromAccount = accountRepository.findByIdForUpdate(fromAccountId);
        Account toAccount = accountRepository.findByIdForUpdate(toAccountId);

        fromAccount.withdraw(amount);
        toAccount.deposit(amount);

        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
        // íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹œì ì— ë½ í•´ì œ
    }

    // 2. ì¬ê³  ê´€ë¦¬ (ì •í™•í•œ ìˆ˜ëŸ‰ ì œì–´)
    public boolean purchaseProduct(Long productId, int quantity) {
        Product product = productRepository.findByIdForUpdate(productId);

        if (product.getStock() >= quantity) {
            product.decreaseStock(quantity);
            productRepository.save(product);
            return true;
        }
        return false;
    }
}
```

### í˜¼í•© ì‚¬ìš© ì˜ˆì‹œ

```java
@Service
public class HybridConcurrencyControl {
    // Java ë™ì‹œì„± ì œì–´ + DB Lock ì¡°í•©
    private final AtomicReference<LocalCache> cache = new AtomicReference<>(new LocalCache());

    @Transactional
    public void updateUserWithCache(Long userId, User updatedUser) {
        // 1. DB Lockìœ¼ë¡œ ë°ì´í„° ì •í•©ì„± ë³´ì¥
        User dbUser = userRepository.findByIdForUpdate(userId);
        dbUser.update(updatedUser);
        userRepository.save(dbUser);

        // 2. Java ë™ì‹œì„± ì œì–´ë¡œ ìºì‹œ ì—…ë°ì´íŠ¸
        cache.updateAndGet(currentCache -> {
            LocalCache newCache = new LocalCache(currentCache);
            newCache.put(userId, dbUser);
            return newCache;
        });
    }
}
```

## ğŸ“Š ë ˆë²¨ë³„ ë™ì‹œì„± ì œì–´ ì„ íƒ ê°€ì´ë“œ

| ìƒí™©                 | Java ë™ì‹œì„± ì œì–´ | DB Lock           |
| -------------------- | ---------------- | ----------------- |
| **ë©”ëª¨ë¦¬ ë‚´ ë°ì´í„°** | âœ… ì í•©          | âŒ ë¶ˆí•„ìš”         |
| **ìºì‹œ ê´€ë¦¬**        | âœ… ì í•©          | âŒ ë¶€ì í•©         |
| **ê³„ì¢Œ ì´ì²´**        | âŒ ë¶ˆì¶©ë¶„        | âœ… í•„ìˆ˜           |
| **ì¬ê³  ê´€ë¦¬**        | âŒ ë¶ˆì¶©ë¶„        | âœ… í•„ìˆ˜           |
| **ì„±ëŠ¥**             | ë¹ ë¦„             | ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦¼   |
| **í™•ì¥ì„±**           | ë‹¨ì¼ JVM         | ì—¬ëŸ¬ ì• í”Œë¦¬ì¼€ì´ì…˜ |

## âš ï¸ ì£¼ì˜ì‚¬í•­

### ThreadLocal ë©”ëª¨ë¦¬ ë¦¬í¬ ë°©ì§€

```java
public class ThreadLocalBestPractice {
    private static final ThreadLocal<ExpensiveObject> EXPENSIVE = new ThreadLocal<>();

    public void goodExample() {
        try {
            EXPENSIVE.set(new ExpensiveObject());
            // ì‘ì—… ìˆ˜í–‰
        } finally {
            EXPENSIVE.remove();  // ë°˜ë“œì‹œ ì •ë¦¬!
        }
    }
}
```

### volatile ì‚¬ìš© ì‹œ ì£¼ì˜ì 

```java
public class VolatileLimit {
    private volatile int counter = 0;

    // âŒ ë³µí•© ì—°ì‚°ì€ ì—¬ì „íˆ ìœ„í—˜
    public void increment() {
        counter++;  // Race Condition ë°œìƒ ê°€ëŠ¥
    }

    // âœ… ë‹¨ìˆœ í• ë‹¹ì€ ì•ˆì „
    public void setValue(int value) {
        counter = value;
    }
}
```

## ğŸ’¡ í•µì‹¬ ì •ë¦¬

### Thread Safe ë°©ë²•ë“¤

- **synchronized**: ê°€ì¥ ì•ˆì „í•˜ê³  ì´í•´í•˜ê¸° ì‰¬ì›€
- **AtomicReference**: ë†’ì€ ì„±ëŠ¥ê³¼ ë¬´ì ê¸ˆ ì•Œê³ ë¦¬ì¦˜
- **volatile**: ë‹¨ìˆœí•œ ê°€ì‹œì„± ë³´ì¥
- **ThreadLocal**: ê° ì“°ë ˆë“œë³„ ë…ë¦½ì  ë°ì´í„°

### ì„ íƒ ê¸°ì¤€

- **ê³µìœ  ë°ì´í„°**: Thread Safe ê¸°ë²• ì‚¬ìš©
- **ë…ë¦½ì  ë°ì´í„°**: ThreadLocal ì‚¬ìš©
- **ë‹¨ìˆœ í”Œë˜ê·¸**: volatile ì‚¬ìš©
- **ë³µì¡í•œ ì—°ì‚°**: AtomicReference ë˜ëŠ” synchronized ì‚¬ìš©
- **DB ë°ì´í„°**: ìƒí™©ì— ë”°ë¼ Java ë™ì‹œì„± ì œì–´ì™€ DB Lock ì¡°í•©

### í•µì‹¬ ì›ì¹™

1. **ìƒí™©ì— ë§ëŠ” ì ì ˆí•œ ë ˆë²¨ ì„ íƒ**
2. **ì„±ëŠ¥ê³¼ ì•ˆì „ì„±ì˜ ê· í˜•**
3. **ë©”ëª¨ë¦¬ ë¦¬í¬ ë°©ì§€**
4. **ì¼ê´€ëœ ë™ì‹œì„± ì „ëµ ìœ ì§€**
