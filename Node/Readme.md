# Node.js

### 노드의 정의

> 공식 홈페이지의 설명

- `Node.js`는 크롬 `V8` 자바스크립트 엔진으로 빌드된 자바스크립트 런타임(실행기)
  - 과거에 브라우저에 `js(스크립트)`를 읽는데 `html`에 종속되어 있었다
  - 노드가 나옴으로 인해 `js`는 `html`이나 브라우저의 종속성에서 벗어남(`V8` 자바스크립트 엔진이 해석)
  - 물론 노드 이전에 `라이노(Rhino)` 등 여러가지가 있었다
    - But, 엔진 속도 문제로 실패
  - 빠른것이 장점 -> 빠른 js의 실행이 장점인 것
- ts 런타임은 `Deno`

> 노드는 서버?

- 서버의 역할도 수행할 수 있는 `js` 런타임
- 노드로 `js로 작성된 서버`를 실행 가능
- 서버 실행을 위해 필요한 `http/https/http2` 모듈을 제공
  - Node.js(런타임), V8(엔진)
  - jre(런타임), jdk(node와 비슷한 역할)

### 런타임

> 노드: js 런타임

- 런타임: 특정 언어로 만든 프로그램을 실행할 수 있게 해주는 가상 머신(크롬 `V8` 자바스크립트 엔진의 사용) 상태
- 노드: js로 만든 프로그램을 실행할 수 있게 해줌
- 다른 런타임으로는 웹 브라우저(크롬, 엣지, 사파리, 파이어폭스 등)가 있음

### 내부 구조

> 2008년 `V8` 엔진 출시, 2009년 노드 프로젝트 시작
> 노드는 `V8`과 `libuv`를 내부적으로 포함

- `V8` 엔진: 오픈 소스 자바스크립트 엔진 -> 속도 문제 개선
- `libuv`: 노드의 특성인 `이벤트 기반`, `Non-Blocking I/O 모델`을 구현한 라이브러리

  - `js`, `node`가 뜬 이유 `싱글 스레드`이면서 `비동기인 모델`이라서
  - 빠른 성능을 이끌어 낼 수 있다
  - Non-Blocking I/O 모델

    > > `논블로킹 I/O 모델`은 컴퓨터 프로그래밍에서 입력/출력 작업을 수행할 때, <mark>작업이 완료될 때까지 기다리지 않고 즉시 다음 작업을 수행할 수 있도록 하는 방식</mark>. 이는 특히 네트워크 서버나 고성능 애플리케이션에서 중요한 개념이다. 논블로킹 I/O 모델의 주요 특징과 장점은 다음과 같다:

    1. **즉각적인 응답성**: I/O 작업이 완료될 때까지 기다리지 않기 때문에 애플리케이션의 응답성이 높아진다. 사용자 경험을 개선하는 데 도움이 된다.

    2. **자원 효율성**: `블로킹 I/O 모델`에서는 하나의 작업이 완료될 때까지 다른 작업이 대기해야 하지만, 논블로킹 I/O 모델에서는 여러 작업을 `동시에` 처리할 수 있어 자원 사용이 효율적이다.

    3. **비동기 처리**: 논블로킹 I/O는 `비동기적`으로 작동하여, I/O 작업이 완료되면 콜백 함수나 이벤트를 통해 결과를 처리할 수 있다.

    4. **적용 사례**: 주로 Node.js와 같은 서버 사이드 자바스크립트 환경이나, Java의 NIO (New Input/Output) 라이브러리, Python의 asyncio 모듈 등에서 사용

    > > > 💡논블로킹 I/O 모델을 사용하면 고성능, 고가용성 애플리케이션을 개발하는 데 큰 도움이 된다. 그러나 코드의 복잡성이 증가할 수 있으므로 적절한 설계와 구현이 필요

- 내부는 `C`, `C++`로 이루어 짐(속도 땜)
  - C: 생산성이 안좋음, `low-level`의 언어, `GC`와 같은 것들을 알아서 해주는 것이 ❌
    ![image](https://github.com/user-attachments/assets/477329a1-3611-4c77-a1b4-7cbfc875ec77)

### 노드의 특성

<b>::이벤트 기반</b>

> 이벤트가 발생할 때 미리 저장해둔 작업을 수행하는 방식

- e.g.) 클릭, 네트워크 요청, 타이머 등
- 이벤트 리스너: 이벤트를 등록하는 함수
- 콜백 함수: 이벤트가 발생했을 때 실행될 함수
  ![image](https://github.com/user-attachments/assets/bf45db04-3dca-472f-9e01-941b7615659a)

<b>::논 블로킹</b>

> 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 나중에 오래 걸리는 함수를 실행

> > 노드는 동기이면서 블로킹, 비동기면서 논 블로킹이다
> > 노드에서는 동기면서 논 블로킹인거랑 비동기면서 블로킹인 것은 없다고 보면 된다.

- `논 블로킹` 방식 하에서 일부 코드는 백그라운드에서 병렬로 실행됨
- 일부 코드: `I/O작업`(파일 시스템 접근, 네트워크 요청), 압축, 암호화 등
- 나머지 코드는 블로킹 방식으로 실행됨
- `I/O작업`이 많을 때 노드 활용성이 극대화
  <br/>
- 흔히들, 비동기이면서 논 블로킹일 때, 노드(프로그램)가 `동시에` 돌아간다고 오해를 한다. 노드에서 `동시`라는 것을 구현하기는 어렵다. `동시`에 돌아가는 것들이 일부 있다.
- `논 블로킹`이라고 무조건 랜덤하게 실행되는 것은 아니다. `실행 컨텍스트`와 `이벤트 루프`라는 규칙이 있다.

<b>::프로세스와 스레드 그 사이 어딘가..</b>

> 프로세스와 스레드

- 프로세스: 운영체제에서 할당하는 작업의 단위 or 실행중인 프로그램이라 배웠던거 같은데.. 프로세스 간 자원 공유는 ❌
- 스레드: 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스 자원 공유
  c.f.) 참고로 실제 크롬은 각 창을 프로세스로 띄운다.

> > 노드 프로세스는 <mark>멀티 스레드</mark>이지만 직접 다룰 수 있는 스레드는 <mark>하나</mark>이기 때문에 싱글 스레드라고 표현
> > 노드는 주로 멀티 스레드 대신 멀티 프로세스 활용
> > 14버전부터 멀티 스레드 사용 가능

<b>::싱글 스레드</b>

> 싱글 스레드라 주어진 일을 하나밖에, 하나의 스크립트 밖에 처리하지 못함

> - 블로킹이 발생하는 경우 나머지 작업은 모두 대기해야 한다 -> 비효율의 극치라고 볼 수 있죠..
> - 하나의 스레드는 보통 cpu의 여러 코어 중 하나의 코어를 담당
> - 멀티 코어라면 컨텍스트 스위칭(`문맥 교환`🙌)을 통해 cpu 자원을 효율적으로 사용 가능
>   > - 단일 코어에서도 컨텍스트 스위칭을 통해 멀티 테스킹 or 멀티 스레딩이 가능
>   >   > - 단일 코어에서는 멀티스레딩이 컨텍스트 스위칭을 통해 이루어질 떄, CPU가 매우 빠르게 스레드 간 전환하여 각 스레드가 실행될 수 있도록 한다.
>   >   >   이로 인해 여러 스레드가 동시에 실행되는 것처럼 보이지만 실제로는 순차(`한 번에 하나의 스레드만 실행`)적으로 실행된다.
>   > - 멀티 코어에서는 멀티스레딩과 멀티태스킹은 각 코어가 독립적으로 작업을 실행하여 진정한 `병렬 처리`가 가능
>   > - 컨텍스트 스위칭 발생 과정(간단하게..)
>   >   1. 요청 발생 : 인터럽트(hardware) 또는 트랩에 의한 요청이 발생 (트랩은 소프트웨어 인터럽트)
>   >   2. PCB에 저장 : 운영체제는 현재 실행중인 프로세스(P0)의 정보를 PCB에 저장
>   >   3. CPU 할당 : 운영체제는 다음 프로세스(P1)의 정보를 PCB에서 가져와 CPU를 할당

> > 참고로 컨텍스트 스위칭 자체는 순서를 보장하지 않지만, 스케줄링 알고리즘과 동기화 메커니즘을 통해 작업의 실행 순서를 제어할 수 있다.

<b>::멀티 스레드 모델과의 비교</b>

> 싱글 스레드 모델은 에러를 처리하지 못하는 경우 멈춤

- 프로그래밍 난이도 easy, CPU, 메모리 자원 적게 사용

> > 멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복

- 단, 새로운 스레드 생성이나 놀고 있는 스레드 처리에 비용 발생
- 프로그래밍 난이도 어려움
- 스레드 수만큼 자원을 많이 사용함

> > > 대신 논 블로킹 모델을 채택하여 일부 코드(`I/O`)를 백그라운드(다른 프로세스)에서 실행 가능

- 요청을 먼저 받고, 완료될 때 응답함
- `I/O` 관련 코드가 아닌 경우 싱글 스레드, 블로킹 모델과 같아짐

> > > > 점원(스레드)이 하나인 체인점(노드 프로세스)을 여러 개 만들어 문제점 해결 -> <mark>멀티 프로세싱(I/O요청이 많을 때 use)</mark>
> > > > 노드의 핵심은 싱글 스레드 하나의 효율적 관리임

- 멀티 스레딩은 CPU 작업이 많을 때.. 사실상 멀티 스레딩은 아쉬움 달래기용임
