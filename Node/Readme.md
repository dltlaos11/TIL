# Node.js

### 노드의 정의

> 공식 홈페이지의 설명

- `Node.js`는 크롬 `V8` 자바스크립트 엔진으로 빌드된 자바스크립트 런타임(실행기)
  - 과거에 브라우저에 `js(스크립트)`를 읽는데 `html`에 종속되어 있었다
  - 노드가 나옴으로 인해 `js`는 `html`이나 브라우저의 종속성에서 벗어남(`V8` 자바스크립트 엔진이 해석)
  - 물론 노드 이전에 `라이노(Rhino)` 등 여러가지가 있었다
    - But, 엔진 속도 문제로 실패
  - 빠른것이 장점 -> 빠른 js의 실행이 장점인 것
- ts 런타임은 `Deno`

> 노드는 서버?

- 서버의 역할도 수행할 수 있는 `js` 런타임
- 노드로 `js로 작성된 서버`를 실행 가능
- 서버 실행을 위해 필요한 `http/https/http2` 모듈을 제공
  - Node.js(런타임), V8(엔진)
  - jre(런타임), jdk(node와 비슷한 역할)

### 런타임

> 노드: js 런타임

- 런타임: 특정 언어로 만든 프로그램을 실행할 수 있게 해주는 가상 머신(크롬 `V8` 자바스크립트 엔진의 사용) 상태
- 노드: js로 만든 프로그램을 실행할 수 있게 해줌
- 다른 런타임으로는 웹 브라우저(크롬, 엣지, 사파리, 파이어폭스 등)가 있음

### 내부 구조

> 2008년 `V8` 엔진 출시, 2009년 노드 프로젝트 시작
> 노드는 `V8`과 `libuv`를 내부적으로 포함

- `V8` 엔진: 오픈 소스 자바스크립트 엔진 -> 속도 문제 개선
- `libuv`: 노드의 특성인 `이벤트 기반`, `Non-Blocking I/O 모델`을 구현한 라이브러리

  - `js`, `node`가 뜬 이유 `싱글 스레드`이면서 `비동기인 모델`이라서
  - 빠른 성능을 이끌어 낼 수 있다
  - Non-Blocking I/O 모델

    > > `논블로킹 I/O 모델`은 컴퓨터 프로그래밍에서 입력/출력 작업을 수행할 때, <mark>작업이 완료될 때까지 기다리지 않고 즉시 다음 작업을 수행할 수 있도록 하는 방식</mark>. 이는 특히 네트워크 서버나 고성능 애플리케이션에서 중요한 개념이다. 논블로킹 I/O 모델의 주요 특징과 장점은 다음과 같다:

    1. **즉각적인 응답성**: I/O 작업이 완료될 때까지 기다리지 않기 때문에 애플리케이션의 응답성이 높아진다. 사용자 경험을 개선하는 데 도움이 된다.

    2. **자원 효율성**: `블로킹 I/O 모델`에서는 하나의 작업이 완료될 때까지 다른 작업이 대기해야 하지만, 논블로킹 I/O 모델에서는 여러 작업을 `동시에` 처리할 수 있어 자원 사용이 효율적이다.

    3. **비동기 처리**: 논블로킹 I/O는 `비동기적`으로 작동하여, I/O 작업이 완료되면 콜백 함수나 이벤트를 통해 결과를 처리할 수 있다.

    4. **적용 사례**: 주로 Node.js와 같은 서버 사이드 자바스크립트 환경이나, Java의 NIO (New Input/Output) 라이브러리, Python의 asyncio 모듈 등에서 사용

    > > > 💡논블로킹 I/O 모델을 사용하면 고성능, 고가용성 애플리케이션을 개발하는 데 큰 도움이 된다. 그러나 코드의 복잡성이 증가할 수 있으므로 적절한 설계와 구현이 필요

- 내부는 `C`, `C++`로 이루어 짐(속도 땜)
  - C: 생산성이 안좋음, `low-level`의 언어, `GC`와 같은 것들을 알아서 해주는 것이 ❌
    ![image](https://github.com/user-attachments/assets/477329a1-3611-4c77-a1b4-7cbfc875ec77)

### 노드의 특성

<b>::이벤트 기반</b>

> 이벤트가 발생할 때 미리 저장해둔 작업을 수행하는 방식

- e.g.) 클릭, 네트워크 요청, 타이머 등
- 이벤트 리스너: 이벤트를 등록하는 함수
- 콜백 함수: 이벤트가 발생했을 때 실행될 함수
  ![image](https://github.com/user-attachments/assets/bf45db04-3dca-472f-9e01-941b7615659a)

<b>::논 블로킹</b>

> 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 나중에 오래 걸리는 함수를 실행

> > 노드는 동기이면서 블로킹, 비동기면서 논 블로킹이다
> > 노드에서는 동기면서 논 블로킹인거랑 비동기면서 블로킹인 것은 없다고 보면 된다.

- `논 블로킹` 방식 하에서 일부 코드는 백그라운드에서 병렬로 실행됨
- 일부 코드: `I/O작업`(파일 시스템 접근, 네트워크 요청), 압축, 암호화 등
- 나머지 코드는 블로킹 방식으로 실행됨
- `I/O작업`이 많을 때 노드 활용성이 극대화
  <br/>
- 흔히들, 비동기이면서 논 블로킹일 때, 노드(프로그램)가 `동시에` 돌아간다고 오해를 한다. 노드에서 `동시`라는 것을 구현하기는 어렵다. `동시`에 돌아가는 것들이 일부 있다.
- `논 블로킹`이라고 무조건 랜덤하게 실행되는 것은 아니다. 동기(`실행 컨텍스트`(this, scpope))와 비동기(`이벤트 루프`)라는 규칙이 있다.

<b>::프로세스와 스레드 그 사이 어딘가..</b>

> 프로세스와 스레드

- 프로세스: 운영체제에서 할당하는 작업의 단위 or 실행중인 프로그램이라 배웠던거 같은데.. 프로세스 간 자원 공유는 ❌
- 스레드: 프로세스 내에서 실행되는 작업의 단위, 부모 프로세스 자원 공유
  c.f.) 참고로 실제 크롬은 각 창을 프로세스로 띄운다.

> > 노드 프로세스는 <mark>멀티 스레드</mark>이지만 직접 다룰 수 있는 스레드는 <mark>하나</mark>이기 때문에 싱글 스레드라고 표현
> > 노드는 주로 멀티 스레드 대신 멀티 프로세스 활용
> > 14버전부터 멀티 스레드 사용 가능

<b>::싱글 스레드</b>

> 싱글 스레드라 주어진 일을 하나밖에, 하나의 스크립트 밖에 처리하지 못함

> - 블로킹이 발생하는 경우 나머지 작업은 모두 대기해야 한다 -> 비효율의 극치라고 볼 수 있죠..
> - 하나의 스레드는 보통 cpu의 여러 코어 중 하나의 코어를 담당
> - 멀티 코어라면 컨텍스트 스위칭(`문맥 교환`🙌)을 통해 cpu 자원을 효율적으로 사용 가능
>   > - 단일 코어에서도 컨텍스트 스위칭을 통해 멀티 테스킹 or 멀티 스레딩이 가능
>   >   > - 단일 코어에서는 멀티스레딩이 컨텍스트 스위칭을 통해 이루어질 떄, CPU가 매우 빠르게 스레드 간 전환하여 각 스레드가 실행될 수 있도록 한다.
>   >   >   이로 인해 여러 스레드가 동시에 실행되는 것처럼 보이지만 실제로는 순차(`한 번에 하나의 스레드만 실행`)적으로 실행된다.
>   > - 멀티 코어에서는 멀티스레딩과 멀티태스킹은 각 코어가 독립적으로 작업을 실행하여 진정한 `병렬 처리`가 가능
>   > - 컨텍스트 스위칭 발생 과정(간단하게..)
>   >   1. 요청 발생 : 인터럽트(hardware) 또는 트랩에 의한 요청이 발생 (트랩은 소프트웨어 인터럽트)
>   >   2. PCB에 저장 : 운영체제는 현재 실행중인 프로세스(P0)의 정보를 PCB에 저장
>   >   3. CPU 할당 : 운영체제는 다음 프로세스(P1)의 정보를 PCB에서 가져와 CPU를 할당

> > 참고로 컨텍스트 스위칭 자체는 순서를 보장하지 않지만, 스케줄링 알고리즘과 동기화 메커니즘을 통해 작업의 실행 순서를 제어할 수 있다.

<b>::멀티 스레드 모델과의 비교</b>

> 싱글 스레드 모델은 에러를 처리하지 못하는 경우 멈춤

- 프로그래밍 난이도 easy, CPU, 메모리 자원 적게 사용

> > 멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복

- 단, 새로운 스레드 생성이나 놀고 있는 스레드 처리에 비용 발생
- 프로그래밍 난이도 어려움
- 스레드 수만큼 자원을 많이 사용함

> > > 대신 논 블로킹 모델을 채택하여 일부 코드(`I/O`)를 백그라운드(다른 프로세스)에서 실행 가능

- 요청을 먼저 받고, 완료될 때 응답함
- `I/O` 관련 코드가 아닌 경우 싱글 스레드, 블로킹 모델과 같아짐

> > > > 점원(스레드)이 하나인 체인점(노드 프로세스)을 여러 개 만들어 문제점 해결 -> <mark>멀티 프로세싱(I/O요청이 많을 때 use)</mark>
> > > > 노드의 핵심은 싱글 스레드 하나의 효율적 관리임

- 멀티 스레딩은 CPU 작업이 많을 때.. 사실상 멀티 스레딩은 아쉬움 달래기용임

### 서버로서의 노드

> 노드 != 서버

- 노드는 서버를 구성할 수 있게 하는 모듈 제공

<b>::노드 서버의 장단점</b>

> > 멀티 스레드 방식에 비해 컴퓨터 자원을 적게 사용
>
> - 싱글 스레드라서 CPU 코어를 하나만 사용
>   > I/O 작업이 많은 서버로 적합
> - CPU 작업이 많은 서버로는 부적합
>   > 멀티 스레드 방식보다 쉬움
> - 하나뿐인 스레드가 멈추지 않도록 관리해야 함
>   > 웹 서버가 내장되어 있음
> - 서버 규모가 커졌을 때 서버를 관리하기 어려움
>   > js의 사용, JSON 형식과 호환이 쉬움
> - 어중간한 성능

> > > CPU 작업을 위해 `AWS Lambda`나 `Google Cloud Functions`같은 별도 서비스 사용
> > > 넷플릭스, 나사 등에서 메인 또는 서브 서버로 사용

> > > > js 런타임이기 때문에 용도가 서버에만 한정되지 않음
> > > > 웹(React), 모바일(RN), 데스크탑(Electron)이 노드 기반으로 동작

### 호출 스택

- 함수 선언, 메모리에 올림
  > 호출 스택(함수의 호출, 자료구조의 스택)
- `Anonymous`(chrome)는 가상의 `전역 컨텍스트`(항상 있다고 생각하는게 좋음)
- 함수 호출 `순서대로` 쌓이고, `역순으로` 실행됨
- 함수 실행이 완료되면 스택(`LIFO`)에서 빠짐 -> js의 실행이 완료되는 시점
- 동기(순서대로)적으로 진행, 비동기 코드를 만났을 땐 `이벤트 루프` 등장

### 이벤트 루프

> 호출스택, 메모리(변수 선언), 백그라운드, 테스크 큐

- 호출 스택의 처리가 백그라운드보다 먼저다 -> 동기 코드가 비동기 코드보다 우선
  - 호출 스택과 백그라운드는 동시에 실행되나 처리의 문제.
    e.g. 백그라운드에서 카운트의 동시 실행
  - 백그라운드에서 `동시에` 돌아간다는 것은 비동기, 멀티 스레드로 돌아간다는 것
    - 백그라운드는 js로 돌아가는게 아니라 다른 언어로(c++, os쪽..?) 돌아감
    - 테스크 큐 또한 그렇다
    - 노드의 `libuv`도 c++로 동작
    - `js`자체는 싱글 스레드고 node 14ver에 `워커 스레드`나 브라우저에 `웹 워커`를 사용해야만 `js`에서 멀티 스레드 사용가능
    - 그래서 그 전에는 싱글 스레드 + 다른 언어의 백그라운드, 테스크 큐로 돌아갔다. 그래서 `동시성`이 있는것
  - 백그라운드로 갈 수 있는 것들이 있다.
    - 타이머, setInterval, 네트워크 요청, 파일 읽는 fs명령어, crypto 등
    ```js
    new Promise((resolve) => {
        resolve('hi);
    }).then(console.log);
    ```
    - `Promise`는 `then`을 만나는 순간 비동기가 된다. 내부까지는 동기
    - 결국 테스크 큐에 `Promise`의 `then`/`catch`, 타이머 등 여러 비동기가 들어갈 수 있는데 백그라운드에서는 어떤 것이 먼저 실행될지는 모른다. 다만 `테스크 큐에 우선순위`는 있음
      - `Promise`의 `then`/`catch`는 다른 비동기 보다 우선순위가 높음
      - `process.nextTick` 또한 우선순위가 다른 비동기에 비해 높다
  - 이외의 것들은 모두 동기적으로

> > 백그라운드에서 처리된 함수가 테스크 큐로 이동하는데, 이벤트 루프가 호출 스택이 비어있을 때 테스크 큐에 있던 함수들을 호출스택으로 이동 시킴

### var, const, let

> 가장 큰 차이점은 블록 스코프(var는 함수 스코프)

- `ES2015` 이후부터는 const와 let
- var은 함수 스코프를 존중하며 const, let은 블록 스코프를 존중
  ```js
  function a() {
    var y = 1;
  }
  console.log(y); // Uncaught ReferenceError: y is not defined
  ```
- const로 선언된 객체의 경우, 객체의 프로퍼티는 변경할 수 있다. 이는 객체의 참조가 변하지 않기 때문
- 객체의 프로퍼티를 변경하는 것은 객체의 참조 자체를 변경하는 것이 아니므로 가능
  ```js
  const aa = { name: "b" }; // aa는 객체 { name: 'b' }를 참조
  aa.name = "bb"; // 객체의 프로퍼티 name을 'bb'로 변경
  ```

### 템플릿 리터럴

```js
function a() {}
a();
== a``; // tagged template literal
```

### 화살표 함수

> 화살표 함수의 this는 부모의 this를 물려받는다.
> function 함수의 this는 자신만의 this

```js
btn.addEventListener("click", function () {
  console.log(this.textContent); // btn에 적혀있는 word
});

this;
btn.addEventListener("click", () => {
  console.log(this.textContent); // 상위 this를 가르킴
});

btn.addEventListener("click", (e) => {
  console.log(e.target.textContent);
});
```

> > this 사용시 function, 안쓰면 arrow
